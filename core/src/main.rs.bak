use clap::{Parser, ValueEnum};
use veil::Redact;

use std::net::SocketAddr;
use std::path::PathBuf;

extern crate num;
#[macro_use]
extern crate num_derive;

mod common;
mod engine;
mod model_executor;
mod sched;
mod worker;

use common::config::EngineArgs;

use crate::engine::llm_engine::LLMEngine;

async fn service_main(args: &EngineArgs) -> anyhow::Result<()> {
    tracing_subscriber::fmt::init();
    // if args.log.is_empty() {
    //     tracing_subscriber::fmt::init();
    // } else {
    //     let file_appender = tracing_appender::rolling::daily("./", args.log.as_str());
    //     //let (non_blocking_appender, _guard) = tracing_appender::non_blocking(file_appender);
    //     tracing_subscriber::fmt().with_writer(file_appender).init();
    //     // tokio::spawn(utils::clean_rotate_logs(format!("./{}", args.log.as_str())));
    // }
    let (model_cfg, cache_cfg, parallel_cfg, sched_cfg) = args.create_engine_configs()?;

    let engine = LLMEngine::from(model_cfg, cache_cfg, parallel_cfg, sched_cfg)?;

    tracing::info!("{args:?}");

    // let recorder = utils::MetricsLogRecorder::new(Duration::from_secs(10));
    // metrics::set_boxed_recorder(Box::new(recorder)).unwrap();

    Ok(())
}

fn main() {
    let args = EngineArgs::parse();

    tokio::runtime::Builder::new_multi_thread()
        .worker_threads(args.threads)
        .enable_all()
        .build()
        .unwrap()
        .block_on(async {
            if let Err(e) = service_main(&args).await {
                tracing::error!("service_main error:{e:?}");
            }
        });
}
